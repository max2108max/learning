Анонимные функциональные выражения быстро и легко вводить и многие библиотеки и утилиты
 проявляют тенденцию к поощрению этого идиоматического стиля кода. Однако, у них есть несколько 
 недостатков о которых нужно упомянуть:


У анонимных функций нет удобного имени для отображения в стектрейсах (stacktrace), что может затруднить отладку.


Если функции без имени будет нужно сослаться на себя же, для рекурсии или чего-то подобного, 
к сожалению требуется устаревшая ссылка arguments.callee. Еще один пример необходимости в ссылке на себя,
когда функция обработчика события хочет отписать себя от события после выполнения.


Анонимные функции опускают имя, что часто удобно для обеспечения большей читаемости/понятности кода. 
Наглядное же имя помогает самодокументировать рассматриваемый код.

IIFE =====>  Immediately Invoked  Function  Expression 

Есть легкая вариация формы традиционной IIFE, которую предпочитают некоторые: (function(){ .. }())

                                                                   популярная (function(){ .. })()



var a = 2;

(function IIFE( global ){

	var a = 3;
	console.log( a ); // 3
	console.log( global.a ); // 2

})( window );

console.log( a ); // 2


===================================================================================================================


undefined = true; // устанавливаем мину для другого кода! остерегайтесь!

(function IIFE( undefined ){

	var a;
	if (a === undefined) {
		console.log( "Undefined is safe here!" );
	}

})();


===================================================================================================================

Этот шаблон используется в проекте UMD (Universal Module Definition). 

var a = 2;

(function IIFE( def ){
	def( window );
})(function def( global ){

	var a = 3;
	console.log( a ); // 3
	console.log( global.a ); // 2

});

===================================================================================================================

var foo = true;

if (foo) {
	var bar = foo * 2;
	bar = something( bar );
	console.log( bar );
}


=====> var bar делает так что bar в глобальной области видимости (если это не внутри функции)


try/catch

 catch имеет блочную область видимости (у каждого catch своя)

try {
	undefined(); // нелегальная операция, чтобы вызвать исключение!
}
catch (err) {
	console.log( err ); // работает!
}

console.log( err ); // ReferenceError: `err` not found


Сборка мусора
Еще одна причина полезности блочной области видимости связана с замыканиями и сборкой мусора, 
чтобы освободить память. Мы кратко проиллюстрируем это здесь, но детально механизм замыканий будет рассматриваться в главе 5.

Пример:

function process(data) {
	// делаем что-то интересное
}

var someReallyBigData = { .. };

process( someReallyBigData );

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );


Обратный вызов обработчика щелчка click совсем не требует переменную someReallyBigData. 
Это значит, теоретически, что после выполнения process(..), большая памятезатратная структура данных 
может быть собрана сборщиком мусора. Однако, весьма вероятно (хотя зависит от реализации), 
что движок JS все еще должен будет оставить структуру в памяти, поскольку у функции click есть замыкание, 
действующее во всей области видимости.

Блочная область видимости может устранить этот недостаток, делая более явным для движка то, что ему не нужна someReallyBigData:

function process(data) {
	// делаем что-то интересное
}

// всё, что объявлено внутри этого блока, может исчезнуть после него!
{
	let someReallyBigData = { .. };

	process( someReallyBigData );
}

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
	console.log("button clicked");
}, /*capturingPhase=*/false );
Объявление явных блоков для переменных, чтобы локально привязать их к блокам — мощный инструмент,
 который вы можете добавить в свой арсенал.
