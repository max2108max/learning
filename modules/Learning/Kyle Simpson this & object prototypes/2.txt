Привязка по умолчанию---------------------------------------------------
правило, действующее по умолчанию когда остальные правила не применяются.

function foo() {
	console.log( this.a );
}

var a = 2;

foo(); // 2


===========================================

function foo() {
	"use strict";

	console.log( this.a );
}

var a = 2;

foo(); // TypeError: `this` is `undefined`

Состояние strict mode в точке вызова foo() не имеет значения.
главное есть ли strict =====> ВНУТРИ foo() <=========



Неявная привязка-------------------------------------------------------

function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

obj.foo(); // 2 this.a — синоним obj.a

======================================

function foo() {
	console.log( this.a );
}

var obj2 = {
	a: 42,
	foo: foo
};

var obj1 = {
	a: 2,
	obj2: obj2
};

obj1.obj2.foo(); // 42 this - будет obj2.foo

Неявно потерянный--------------------------------------------------

когда вызов ==> obj.foo()

function foo() {
	console.log( this.a );
}

var obj = {
	a: 2,
	foo: foo
};

var a = "ой, глобальная"; // `a` еще и переменная в глобальном объекте

setTimeout( obj.foo, 100 ); // "ой, глобальная"

Явная привязка--------------------------------------------------
 

 function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

foo.call( obj ); // 2


Если this  примитивное значение (типа string, boolean или number), 
то будет обернуто в свою объектную форму new String(..), new Boolean(..)  и т.д.
 Часто это называют "обертка".

 *Примечание: * В отношении привязки this call(..) и apply(..) идентичны. 
 Они по-разному ведут себя с дополнительными параметрами, но мы не будем сейчас на этом останавливаться.

 Жесткая  привязка--------------------------------------------------

 function foo() {
	console.log( this.a );
}

var obj = {
	a: 2
};

var bar = function() {
	foo.call( obj );
};

bar(); // 2
setTimeout( bar, 100 ); // 2

// `bar` жестко привязывает `this` в `foo` к `obj`
// поэтому его нельзя перекрыть
bar.call( window ); // 2


======================================

function foo(something) {
	console.log( this.a, something );
	return this.a + something;
}

var obj = {
	a: 2
};

var bar = foo.bind(obj)


var b = bar( 3 ); // 2 3
console.log( b ); // 5

Привязка new---------------------------------------------------

функция вызывается с указанием перед ней new

1. Создается новенький объект (т.е. конструируется) прямо из воздуха
2. Только что сконструированный объект связывается с [[Прототипом]]
3. Только что сконструированный объект устанавливается как привязка this для этого вызова функции
4. За исключением тех случаев, когда функция возвращает свой собственный альтернативный объект, 
   вызов функции с new автоматически вернет только что сконструированный объект.

   function foo(a) {
	this.a = a;
}

var bar = new foo( 2 );
console.log( bar.a ); // 2

мы конструируем новый объект и устанавливаем этот новый объект как thisдля вызова foo(..).
Таким образом new — единственный путь, которым this при вызове функции может быть привязан.

Определяем this---------------------------------------------------------

1. Функция вызвана с new (привязка new)? 
   Раз так, то this — новый сконструированный объект.
   var bar = new foo()

2. Функция вызвана с call или apply (явная привязка), даже скрыто внутри жесткой привязки в bind? 
   Раз так, this — явно указанный объект.
   var bar = foo.call( obj2 )

3. Функция вызвана с контекстом (неявная привязка), иначе называемым как владеющий или содержащий объект?
   Раз так, this является тем самым объектом контекста.
   var bar = obj1.foo()

4. В противном случае, будет this по умолчанию (привязка по умолчанию). 
   В режиме strict mode, это будет undefined, иначе будет объект global.
   var bar = foo()

Проигнорированный this--------------------------------------------------

Если вы передаете null или undefined в качестве параметра привязки this в call, apply или bind, 
то эти значения фактически игнорируются,
а взамен к вызову применяется правило привязки по умолчанию.

function foo(a,b,c) {
	console.log( "a:" + a + ", b:" + b,"c:" + c );
}

// распакуем массив как параметры
foo.apply( null, [2, 3, 4] ); // a:2, b:3

// каррируем с помощью `bind(..)`
var bar = foo.bind( null, 2, 3 );
bar( 4 ); // a:2, b:3


Однако, есть некоторая скрытая "опасность" в том, чтобы всегда использовать null, 
когда вам не нужна привязка this. Если вы когда-нибудь воспользуетесь этим при вызове функции 
(например, функции сторонней библиотеки, которой вы не управляете) и эта функция все-таки воспользуется 
ссылкой на this, сработает правило привязки по умолчанию, что повлечет за собой ненамеренно ссылку 
(или еще хуже, мутацию!) на объект global (window в браузере).


========================================================

function foo() {
	console.log( this.a );
}

var a = 2;
var o = { a: 3, foo: foo };
var p = { a: 4 };

o.foo(); // 3
(p.foo = o.foo)(); // 2   это тоже самое что и просто foo()